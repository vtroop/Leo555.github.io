{"title":"lizhen's blog","description":"Lizhen's personal static blog.","language":"","link":"https://lz5z.com","pubDate":"Fri, 24 Aug 2018 10:25:35 GMT","lastBuildDate":"Fri, 24 Aug 2018 04:05:51 GMT","generator":"hexo-generator-json-feed","webMaster":"lizhen","items":[{"title":"再见金山，你好腾讯","link":"https://lz5z.com/GoodByeKingsoft-HelloTencent/","description":"有什么感受在金山的最后一天了，从昨天早上就开始了划水摸鱼的工作模式，主要是把项目的代码结构给几位同事讲一下，还有一些比较容易让人困惑的点，才发现我对项目是如此熟悉，大部分代码如数家珍。从 2017 年 2 月 14 号情人节入职到明天 2018 年 8 月 24 正式离职，差不多在这里呆了一年半的时间，自己的进步自己看得到，周围的同事也看得到。老大曾经对我说，感觉入职的时候对我的评级评低了。听到以后很开心，可能不是评低了，是我确实进步了不少。跟去年要离开 OOCL 的时候感觉不同，那个时候正好赶上过年并且自己做的项目没有东西可以做，所以非常轻松，走之前差不多很长一段时间都在摸鱼。而这次从金山离职，从提出离职申请到昨天，基本上每天都有事情要做，赶需求，改 Bug，招新人，讲代码，交接功能，一直忙个不停。可见自己的重要性提高了，所以非常谨慎地又将一些可能留下的问题改了又改，争取不给后面的同事埋坑。","pubDate":"Fri, 24 Aug 2018 10:25:35 GMT","guid":"https://lz5z.com/GoodByeKingsoft-HelloTencent/","category":"Work"},{"title":"Symbol","link":"https://lz5z.com/JavaScript-Symbol/","description":"ES2018新特性学习 中又回顾到了 symbol 数据类型。Symbol 作为一种原始数据类型，除了其 Symbol.iterator 属性和 Symbol.asyncIterator 属性为数据提供 for...of 和 for...await...of 访问机制外，它还有什么功能呢？或者说，ES6 中增加 Symbol 数据类型主要面对什么场景呢？Symbol 简介Symbol() 函数返回 symbol 类型的值，该类型具有静态属性和静态方法，并且不支持 new Symbol() 语法。每个从 Symbol() 函数中返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符，这是该数据类型最大的目的。","pubDate":"Mon, 09 Jul 2018 21:31:49 GMT","guid":"https://lz5z.com/JavaScript-Symbol/","category":"JavaScript"},{"title":"HTTP 协议 Transfer-Encoding","link":"https://lz5z.com/HTTP-Transfer-Encoding/","description":"简介Transfer-Encoding (传输编码) 是常见的 HTTP 头 字段，表示将实体安全传递给用户所采用的编码形式。与另外一个更为常见的 Content-Encoding 不同，Content-Encoding 表示内容编码，通常用于对实体内容进行压缩编码，比如 gzip，deflate 等。而 Transfer-Encoding 不会减少实体内容传输大小，但是会改变实体传输的形式。Content-Encoding 和 Transfer-Encoding 二者是相辅相成的，对于一个 HTTP 报文，很可能同时进行了内容编码和传输编码。在 HTTP 请求头中，Transfer-Encoding 被称为 TE，表示浏览器预期接受的传输编码方式，可使用 Response 头 Transfer-Encoding 字段中的值，比如 chunked；另外还可用 trailers 这个值来表明浏览器希望在最后一个大小为 0 的块之后还接收到一些额外的字段。","pubDate":"Mon, 09 Jul 2018 00:08:27 GMT","guid":"https://lz5z.com/HTTP-Transfer-Encoding/","category":"网络"},{"title":"HTTP 状态码 301 与 302 的区别","link":"https://lz5z.com/HTTP-301-vs-302/","description":"301 和 302 有啥区别301 Moved Permanently，永久重定向。被请求资源已永久移动到新位置，并且将来任何对该资源的引用都使用本响应返回的若干个 URI 之一。301 资源除非额外指定，否则都是可缓存的。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。302 Found 表示临时重定向 Moved Temporarily。由于这样的重定向是临时的，客户端应继续向原有地址发送以后的请求，只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。注意：虽然 RFC1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。因此状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。","pubDate":"Sun, 08 Jul 2018 20:28:56 GMT","guid":"https://lz5z.com/HTTP-301-vs-302/","category":"网络"},{"title":"ES2018新特性学习","link":"https://lz5z.com/ES2018新特性学习/","description":"ECMAScript 2018 (ES9) 在 6 月底正式发布，带来了很多新特性。关于 ES7 和 ES8 相关的知识，可以查看这篇文章 ES2016 和 ES2017 学习。目前大部分 ES7 和 ES8 的特性都得到主流浏览器的支持，而 ES9 的新特性还未能实现很好的兼容性。关于 ES7/8/9 全部特性可以查看 tc39 官方的 proposals，这些都是最后进入 stage 4 的特性。ES9 的新特性：Lifting template literal restriction 模板语法修正s (dotAll) flag for regular expressions (正则表达式 dotAll 模式)RegExp named capture groups (正则表达式命名捕获组)Rest/Spread Properties (Rest/Spread 属性)RegExp Lookbehind Assertions (正则表达式反向(lookbehind)断言)RegExp Unicode Property Escapes (正则表达式 Unicode 转义)Promise.prototype.finallyAsynchronous Iteration (异步迭代器)","pubDate":"Mon, 02 Jul 2018 19:47:59 GMT","guid":"https://lz5z.com/ES2018新特性学习/","category":"JavaScript"},{"title":"《深入浅出Node.js》-玩转进程","link":"https://lz5z.com/深入浅出Node-js-玩转进程/","description":"第九章 玩转进程Node 基于 V8 引擎构建，采用单线程模型，所有的 JavaScript 将会运行在单个进程的单个线程上，它带来的好处是：没有多线程中常见的锁以及线程同步的问题，操作系统在调度时也能减少上下文切换，提高 CPU 使用率。但是如今 CPU 基本均是多核的，真正的服务器往往还有多个 CPU，一个 Node 进程只能利用一个核，这带来硬件资源的浪费。另外，Node 运行在单线程之上，一个单线程抛出异常而没有被捕获，将会导致进程的崩溃。严格来说，Node 并非真正的单线程，Node 自身中还有 I/O 线程存在，这些 I/O 线程由底层 libuv 处理，这部分线程对于 JavaScript 而言是透明的，只有 C++ 扩展时才会关注到，JavaScript 代码运行在 V8 上，是单线程的。","pubDate":"Mon, 18 Jun 2018 17:28:28 GMT","guid":"https://lz5z.com/深入浅出Node-js-玩转进程/","category":"Node"},{"title":"《深入浅出Node.js》-WebSocket","link":"https://lz5z.com/深入浅出Node-js-WebSocket/","description":"构建 WebSocket 服务WebSocket 与 Node 之间的配合可以说是天作之合：WebSocket 客户端基于事件的编程模型与 Node 中自定义事件相差无几；WebSocket 实现了客户端与服务器之间的长连接，而 Node 在与大量客户端之间保持高并发连接方面非常擅长。WebSocket 有以下好处：客户端与服务器之间只需要建立一个 TCP 连接，可以使用更少的连接。WebSocket 服务器可以推送数据到客户端，比 HTTP 请求响应模型更灵活。WebSocket 协议头更加轻量，减少数据传输。WebSocket 既可以发送文本，也可以发送二进制数据。WebSocket 没有同源限制，客户端可以与任意服务器通信。建立在 TCP 协议之上，与 HTTP 协议有很好的兼容性，默认端口也是 80 和 443。","pubDate":"Fri, 08 Jun 2018 11:58:26 GMT","guid":"https://lz5z.com/深入浅出Node-js-WebSocket/","category":"Node"},{"title":"《深入浅出Node.js》-网络编程","link":"https://lz5z.com/深入浅出Node-js-网络编程/","description":"第七章 网络编程Node 中提供了 net，dgram，http，https 四个模块，分别用来处理 TCP，UDP，HTTP，HTTPS，适用于客户端和服务器。TCPTCP 传输控制协议，在 OSI 模型中属于传输层，许多应用层的协议基于 TCP 构建，比如 HTTP，SMTP，IMAP 等。回顾一下 OSI 模型。第 7 层：应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括： HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。第 6 层：表示层把数据转换为接受者能够兼容并且适合传输的内容，比如数据加密，压缩，格式转换等。第 5 层：会话层负责数据传输中设置和维持网络设备之间的通信连接。管理主机之间的会话进程，还可以利用在数据中插入校验点来实现数据的同步。第 4 层：传输层把传输表头加至数据形成数据包，完成端到端的数据传输。传输表头包含了协议等信息，比如: TCP，UDP 等。第 3 层：网络层负责对子网间的数据包进行寻址和路由选择，还可以实现拥塞控制，网际互联等功能。网络层的协议包括：IP，IPX 等。第 2 层：数据链路层在不可靠的物理介质上提供可靠的传输，主要主要为：物理地址寻址、数据封装成帧、流量控制、数据校验、重发等。第 1 层：物理层在局域网上传送数据帧，负责电脑通信设备与网络媒体之间的互通，包括针脚，电压，线缆规范，集线器，网卡，主机适配等。","pubDate":"Wed, 30 May 2018 00:12:53 GMT","guid":"https://lz5z.com/深入浅出Node-js-网络编程/","category":"Node"},{"title":"《深入浅出Node.js》-理解Buffer","link":"https://lz5z.com/深入浅出Node-js-理解Buffer/","description":"第六章 理解 BufferBuffer 结构Buffer 是一个像 Array 的对象，主要用来操作字节。Buffer 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关的部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现。Buffer 所占用的内存不是通过 V8 分配的，而是堆外内存。由于 V8 垃圾回收性能的影响，将 Buffer 对象用更高效的专有内存分配回收策略来管理。Buffer 在 Node 进程启动的时候已经载入了，并将其放在全局对象 global 上，因此无需 require() 就能使用。Buffer 对象Buffer 的元素为 16 进制的两位数，即 0 到 255 的数值。123var str = '深入浅出node.js'var buf = new Buffer(str, 'utf8')console.log(buf) // &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;不同编码的字符串占用的元素个数各不相同，中文在 UTF-8 编码下占用 3 个元素，字母和半角标点占用 1 个元素。Buffer 可以通过 length 属性得到长度，也可以通过下标访问元素。","pubDate":"Mon, 28 May 2018 22:11:29 GMT","guid":"https://lz5z.com/深入浅出Node-js-理解Buffer/","category":"Node"},{"title":"《深入浅出Node.js》-内存控制","link":"https://lz5z.com/深入浅出Node-js-内存控制/","description":"第五章 内存控制本章学习 V8 的垃圾回收机制以及如何高效使用内存，内存泄漏以及如何排查内存泄漏。V8 的垃圾回收机制与内存限制关于 JavaScript 中常用的垃圾回收机制，可以参考这篇文章 JavaScript 垃圾回收。V8 的内存限制一般后端开发语言中，在基本的内存使用上都没有什么限制，而 Node 中将 JavaScript 的使用内存做出如下限制：64 位操作系统约为 1.4G，32 位操作系统约为 0.7G。在这样的限制下，Node 无法直接操作大内存对象，比如将一个 2GB 文件读取到内存中进行字符串分析，即使物理内存有 32 GB。V8 的对象分配在 V8 中，所有的 JavaScript 对象都是通过堆来进行内存分配的，Node 中可以通过 process.memoryUsage() 查看内存使用情况。123456$ node&gt; process.memoryUsage()&gt; &#123; rss: 24244224, heapTotal: 9232384, heapUsed: 5041608, external: 11497 &#125;","pubDate":"Sun, 27 May 2018 21:14:20 GMT","guid":"https://lz5z.com/深入浅出Node-js-内存控制/","category":"Node"},{"title":"《深入浅出Node.js》-异步I/O","link":"https://lz5z.com/深入浅出Node-js-异步I-O/","description":"第三章 异步 I/O异步的概念首先在 Web2.0 中火起来，是因为浏览器中 JavaScript 在单线程上执行，而且它还与 UI 渲染共用一个线程。这意味着 JavaScript 在执行的时候 UI 渲染和响应是处于停滞状态的。前端通过异步的方式来消除 UI 阻塞的现象。假如业务场景中有一组互不相关的任务需要完成，可以采用下面两种方式。单线程串行一次执行。多线程并行执行。如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。多线程的代价在于创建线程和执行期间线程上下文切换的开销较大。另外，在复杂业务中，多线程编程经常面临锁、状态同步等问题。但是多线程能有效利用 CPU。单线程顺序执行比较符合编程人员按照顺序思考的思维方式，也是最主流的编程方式。缺点在于执行性能，任何一个略慢的任务都会导致后续执行代码被阻塞。Node 在两者之间给出了它的方案：利用单线程，远离多线程死锁，状态同步问题；利用异步 I/O，让单线程远离阻塞，更好地利用 CPU。异步 I/O 就是 I/O 的调用不再阻塞后续计算，将原有等待 I/O 完成这段时间分配给其它需要的业务去执行。","pubDate":"Fri, 25 May 2018 22:20:38 GMT","guid":"https://lz5z.com/深入浅出Node-js-异步I-O/","category":"Node"},{"title":"《深入浅出Node.js》-读书笔记","link":"https://lz5z.com/深入浅出Node-js-读书笔记/","description":"简介不知不觉 Node 已经更新到第十个版本了，本人使用 Node 也有两年多时间，之前学习的东西一直零零散散，没有形成系统的知识体系，于是最近又抽时间回顾这本经典的 《深入浅出Node.js》，阅读的过程中，难免有些东西不易理解或者容易忘记，因此选择博客的形式记录。作者书写这本书的时候，Node 的稳定版本为 v0.10.13，当前最高版本为 v10.1.0，不过整个 Node 的核心体系在当时已经形成，因此对更高版本的理解问题不大。第一章 Node 简介Node 诞生于 2009 年 3 月，作者为 Ryan Dahl。作者选择 JavaScript 作为 Node 的实现语言主要因为：JavaScript 高性能（V8），符合事件驱动，没有后端历史包袱。除了 HTML、WebKit 和显卡这些与 UI 相关技术没有支持外，整个 Node 的结构与 Chrome 非常相似，它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。","pubDate":"Wed, 23 May 2018 22:51:15 GMT","guid":"https://lz5z.com/深入浅出Node-js-读书笔记/","category":"Node"},{"title":"HTTPS 加密原理","link":"https://lz5z.com/HTTPS加密原理/","description":"前面几天学习 DNS 缓存的时候，了解到了 DNS 劫持和 HTTP 劫持，关于 DNS 劫持和 HTTP 劫持的区别，知乎上一位同学给出了有趣的比喻DNS劫持和HTTP劫持有什么区别？:DNS 劫持：你输入的网址是 http://www.google.com，出来的是百度的页面。HTTP 劫持：你打开的是知乎的页面，右下角弹出唐老师的不孕不育广告（2018年更：右下角弹出：偶系渣渣辉）。应对 HTTP 劫持最有效的方法就是 HTTPS。本文学习 HTTPS 相关的知识。在学习之前首先抛出三个问题：HTTPS 加密原理是什么？HTTPS 是否安全？为什么？为什么抓包工具比如 Fiddler/Charles 能抓取 HTTPS 协议的包？","pubDate":"Tue, 22 May 2018 21:05:58 GMT","guid":"https://lz5z.com/HTTPS加密原理/","category":"网络"},{"title":"Web 性能优化-首屏和白屏时间","link":"https://lz5z.com/Web性能优化-首屏和白屏时间/","description":"什么是首屏和白屏时间？白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成影响白屏时间的因素：网络，服务端性能，前端页面结构设计。影响首屏时间的因素：白屏时间，资源下载执行时间。以百度为例，将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮，查看 Screenshots 如下图：","pubDate":"Thu, 17 May 2018 19:24:09 GMT","guid":"https://lz5z.com/Web性能优化-首屏和白屏时间/","category":"性能"},{"title":"Web 性能优化-缓存-HTTP 缓存","link":"https://lz5z.com/Web性能优化-HTTP缓存/","description":"浏览器缓存HTTP 缓存通常要配合客户端（浏览器）使用才能发挥效果，所以又被称之为浏览器缓存，是 Web 性能优化的一大利器。缓存类型浏览器缓存分为强缓存和协商缓存。(1) 强缓存：浏览器在加载资源的时候，根据资源的 HTTP Header 判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。(2) 协商缓存：当强缓存没有命中的时候，浏览器向服务器发送请求，服务器端依据资源的另外一些 HTTP Header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回 304，浏览器从缓存中加载这个资源；若未命中请求，服务端返回 200 并将资源返回客户端，浏览器更新本地缓存数据。","pubDate":"Wed, 16 May 2018 16:39:55 GMT","guid":"https://lz5z.com/Web性能优化-HTTP缓存/","category":"性能"},{"title":"Web 性能优化-缓存-DNS 缓存","link":"https://lz5z.com/Web性能优化-DNS缓存/","description":"缓存梗概缓存技术几乎存在于网络技术发展的各个角落，从数据库到服务器，从服务器到网络，再从网络到客户端，缓存随处可见。跟前端有关的缓存技术主要有：DNS 缓存，HTTP 缓存，浏览器缓存，HTML5 缓存（localhost/manifest）和 service worker 中的 cache api。DNS 缓存当用户在浏览器中输入网址的地址后，浏览器要做的第一件事就是解析 DNS：(1) 浏览器检查缓存中是否有域名对应的 IP，如果有就结束 DNS 解析过程。浏览器中的 DNS 缓存有时间和大小双重限制，时间一般为几分钟到几个小时不等。DNS 缓存时间过长会导致如果 IP 地址发生变化，无法解析到正确的 IP 地址；时间过短会导致浏览器重复解析域名。(2) 如果浏览器缓存中没有对应的 IP 地址，浏览器会继续查找操作系统缓存中是否有域名对应的 DNS 解析结果。我们可以通过在操作系统中设置 hosts 文件来设置 IP 与域名的关系。","pubDate":"Wed, 16 May 2018 13:32:17 GMT","guid":"https://lz5z.com/Web性能优化-DNS缓存/","category":"性能"},{"title":"Web 性能优化-CSS3 硬件加速(GPU 加速)","link":"https://lz5z.com/Web性能优化-CSS3硬件加速/","description":"CSS3 硬件加速简介上一篇文章学习了重绘和回流对页面性能的影响，是从比较宏观的角度去优化 Web 性能，本篇文章从每一帧的微观角度进行分析，来学习 CSS3 硬件加速的知识。CSS3 硬件加速又叫做 GPU 加速，是利用 GPU 进行渲染，减少 CPU 操作的一种优化方案。由于 GPU 中的 transform 等 CSS 属性不会触发 repaint，所以能大大提高网页的性能。我做了一个页面，左边元素的动画通过 left/top 操作位置实现，右边元素的动画通过 transform: translate 实现，你可以打开 chrome 的 “Paint flashing” 查看，绿色部分是正在 repaint 的内容。查看地址从 demo 中可以看到左边的图形在运动时外层有一圈绿色的边框，表示元素不停地 repaint，并且可以看到其运动过程中有丢帧现象，具体表现为运动不连贯，有轻微闪动。","pubDate":"Thu, 03 May 2018 20:10:40 GMT","guid":"https://lz5z.com/Web性能优化-CSS3硬件加速/","category":"性能"},{"title":"Web 性能优化-页面重绘和回流（重排）","link":"https://lz5z.com/Web性能优化-页面重绘和回流/","description":"前言早在五年前，Google 就提出了 1s 完成终端页面的首屏渲染的标准。常见的优化网络请求的方法有：DNS Lookup，减少重定向，避免 JS、CSS 阻塞，并行请求，代码压缩，缓存，按需加载，前端模块化…","pubDate":"Wed, 02 May 2018 21:46:24 GMT","guid":"https://lz5z.com/Web性能优化-页面重绘和回流/","category":"性能"},{"title":"前端模块化-CommonJS,AMD,CMD,ES6","link":"https://lz5z.com/JavaScript模块化-CommonJS-AMD-CMD-ES6/","description":"模块化解决什么问题随着 JavaScript 工程越来越大，团队协作不可避免，为了更好地对代码进行管理和测试，模块化的概念逐渐引入前端。模块化可以降低协同开发的成本，减少代码量，同时也是“高内聚，低耦合”的基础。模块化主要解决两个问题：命名冲突文件依赖：比如 bootstrap 需要引入 jquery，jquery 文件的位置必须要 bootstrap.js 之前引入。","pubDate":"Thu, 26 Apr 2018 23:03:17 GMT","guid":"https://lz5z.com/JavaScript模块化-CommonJS-AMD-CMD-ES6/","category":"JavaScript"},{"title":"JavaScript 垃圾回收","link":"https://lz5z.com/JavaScript垃圾回收/","description":"垃圾回收JavaScript 具有自动垃圾回收机制，这种垃圾回收机制原理其实很简单：找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。局部变量只有在函数执行的过程中存在，在这个过程中，会为局部变量在栈（或者堆）内存上分配空间，然后在函数中使用这些变量，直至函数执行结束。垃圾回收器必须追踪哪个变量有用哪个没用，对于不再有用的变量打上标记，以备将来回收其占用的内存，用于标识无用变量的策略主要有标记清除法和引用计数法。","pubDate":"Wed, 25 Apr 2018 18:01:21 GMT","guid":"https://lz5z.com/JavaScript垃圾回收/","category":"JavaScript"},{"title":"JavaScript 常见的内存泄漏","link":"https://lz5z.com/JavaScript-Memory-Leaks/","description":"什么是内存泄漏JavaScript 是一种垃圾回收语言，垃圾回收语言通过周期性地检查之前被分配的内存是否可以从应用的其它部分访问来帮助开发者管理内存。内存泄露是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。","pubDate":"Mon, 23 Apr 2018 22:07:24 GMT","guid":"https://lz5z.com/JavaScript-Memory-Leaks/","category":"JavaScript"},{"title":"Vim 学习","link":"https://lz5z.com/vim-study/","description":"本文的内容来自 vimtutor(v1.7)，在 Unix 系统下输入 “vimtutor” 即可进入教学模型。这里记录下来学习点滴，方便以后查看。Vim 简介Vim 是一款由 Vi 派生出来的命令行编辑器，具有语法高亮、代码折叠、多语言支持、多视图等强大的功能，并且支持插件扩展和调用脚本语言。Vim 有多种模式，其中最常用的为插入和执行模式，仅仅通过键盘来在这些模式之中切换，大大提高了程序开发效率。Vim 使用移动光标123456要移动光标使用 h、j、k、l 键 ^ k &lt; h l &gt; j v","pubDate":"Thu, 19 Apr 2018 13:09:32 GMT","guid":"https://lz5z.com/vim-study/","category":"Tools"},{"title":"使用 requestAnimationFrame 实现动画","link":"https://lz5z.com/requestAnimationFrame/","description":"如何实现一个动画我们来实现一个最简单的需求，将一个元素从屏幕左边均匀地移动到屏幕右边。下面是效果:.animate-warpper{width:100%;height:70px}@keyframes move_animation{0%{left:0}100%{left:calc(100% - 60px)}}.animate-div{width:60px;height:40px;position:absolute;left:0;border-radius:5px;background:#92B901;transform:translateZ(0);-webkit-transform:translateZ(0);animation:move_animation 5s linear 2s infinite alternate}","pubDate":"Sat, 14 Apr 2018 18:24:28 GMT","guid":"https://lz5z.com/requestAnimationFrame/","category":"JavaScript"},{"title":"JavaScript 循环与异步","link":"https://lz5z.com/JavaScript-Loop-Async/","description":"JS 中的循环与异步JS 中有多种方式实现循环：for; for in; for of; while; do while; forEach; map 等等。假如循环里面的内容是异步并且 await 的，那异步代码究竟是像 Promise.all一样将循环中的代码一起执行，还是每次等待上一次循环执行完毕再执行呢？首先看结论forEach 和 map, some, every 循环是并行执行的，相当于 Promise.all，其它 for, for in, for of, while, do while 都是串行执行的。先定义异步函数 foo 和可遍历数组 arr：123456789const arr = Array.from(&#123; length: 5 &#125;, (v, k) =&gt; k)const foo = i =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) resolve('') &#125;, 1000) &#125;)&#125;","pubDate":"Wed, 11 Apr 2018 14:03:53 GMT","guid":"https://lz5z.com/JavaScript-Loop-Async/","category":"JavaScript"},{"title":"正则表达式格式化查询参数","link":"https://lz5z.com/QueryStringFormat-RegExp/","description":"记录一下，通过一行正则表达式和 replace 方法简单实现正则表达式格式化查询参数。123456789101112131415161718const url = 'https://lz5z.com/000/?a=123&amp;b=456&amp;c=%E4%B8%AD%E6%96%87'/** * 格式化查询字符串(正则实现) * @param url url地址 * @return &#123;Object&#125; 格式化的json对象 */function formatUrl(url) &#123; const reg = /(?:[?&amp;]+)([^&amp;]+)=([^&amp;]+)/g let data = &#123;&#125; function fn(str, key, value) &#123; data[decodeURIComponent(key)] = decodeURIComponent(value) &#125; url.replace(reg, fn) return data&#125;console.log(formatUrl(url)) // &#123; a: '123', b: '456', c: '中文' &#125;下次面试官问你的时候，你能答上来吗？😉😉😉","pubDate":"Mon, 26 Mar 2018 23:05:05 GMT","guid":"https://lz5z.com/QueryStringFormat-RegExp/","category":"JavaScript"}]}